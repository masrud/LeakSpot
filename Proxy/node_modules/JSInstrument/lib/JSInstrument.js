var fs = require('fs');
var estraverse = require('estraverse');
var esprima = require('esprima');
var escodegen = require('escodegen');
var crypto = require('crypto');
require('../../../lib/profilerLib.js');

module.exports = function() {
    return new JSINSTRUMENT();
}

var Parsing_mode = {
    PARSE: 'PARSE',
    MINIFIED: 'MINIFIED',
    UNMODIFIED: 'UNMODIFIED'
}    

var JSINSTRUMENT = function() {
    var thatModule = this;
    //TODO: access to function arguments
    this.options = {
        NEWEXPRESSION_INST : 1,  //Create
        CALLEXP_INST       : 1,  //ACCESS functions, methods
        FUNCTINEXP_INST    : 1,  //Create + Function Declaration inside
        FUNCDECL_INST      : 1,  //Function Declaration inside
        PROGRAM_INST       : 1,  //Function Declaration insdie
        OBJEXP_INST        : 1,  //Create
        ARRAYEXP_INST      : 1,  //Create
        IDENTIF_INST       : 1,  //ACCESS OBJECT
        MEMBEREXP_INST     : 1,  //ACCESS OBJECT
        ASSIGNMENT_INST    : 1, //Reference creation
        WRITE_INST         : 1, //Reference creation
        WRITE_INST_EXP     : 1, //Reference creation
        ACCUMULATION_POINT : 1, //Reference creation
        RECORD_RIGHT_NULL  : 0, //set to null
        INFILE_INST        : 0,
        LITERAL_INST       : 0,
        PARSING_MODE       : Parsing_mode.PARSE
    }

    this.setOptions = function (options) {
        this.options.PARSING_MODE = options.parsing_mode;
    }

    //TODO: Callexpression not s

    var PREFIX1 = "JSProf";
    var loggerLib = JSProf;
    var RP = PREFIX1+"_";
    //TODO: take the object that is returned by a function call!

    //There is no need for special consideration of innerHTML during instrumentation.
    //This is especially true since the name of a property may change. Instead, we 
    //need to handle this during runtime. When a property is being accessed
    // If it checks the value of the property, and if it is innerHTML, then it applies
    //observe function on the specified object....

    var ScopeType = {
        FunctionDec: 1,
        FuncExp: 2
    };

    var CONTEXT = {
        RHS: 1,
        IGNORE: 2,
        OEXP: 3,
        PARAMS: 4,
        OEXP2: 5,
        INC: 6,
        OEXP3: 7
    };
    //Before finalizing and enough testingh let's have the name of the 
    //functions/Builtin Data types.

    var  
    N_LOG_ARRAY_LIT = 10,   //Array Expression   //anonymous
    N_LOG_OBJECT_LIT = 11,   //Object Expression  //anonymous
    N_LOG_FUNCTION_LIT = 12,  //Function Expression  
    N_LOG_STRING_LIT = 21,   
    N_LOG_NUMBER_LIT = 22,
    N_LOG_BOOLEAN_LIT = 23,
    N_LOG_UNDEFINED_LIT = 24,
    N_LOG_NULL_LIT = 25,             
    N_LOG_OBJECT_NEW_INSTANCE = 40, //instances
    N_LOG_BUILTIN_ARRAY = 42,  //Arrays
    N_LOG_BUILTIN_DATE = 43,   //Date
    N_LOG_REGEXP_LIT = 44; //RegExp

    var Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator'
    };

    function logFunctionName(funcname) {
        return PREFIX1+"."+funcname;
    }

    function createLiteralAst(name) {
        return {type: Syntax.Literal, value: name};
    }

    function createIdentifierAst(name) {
        return {type: Syntax.Identifier, name: name};
    }


    var that = this;

    this.updateLID = function (newLID) {
        this.LID = newLID;
    }

    var inc = 1; 
    this.LID = 2;

    function getLId() {
        //console.log("that.LDI ==== " + that.LID);
        var tmpIid = that.LID; 
        that.LID = that.LID + inc; 
        // console.log("that.LDI NEXT ==== " + that.LID);
        return createLiteralAst(tmpIid);
    }    

    function getPreviousLId() {
        var tempIid = that.LID - inc;
        return createLiteralAst(tempIid);
    }

    function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    function isArr(val) {
        return Object.prototype.toString.call( val ) === '[object Array]';
    }

    function MAP(arr, fun) {
        var len = arr.length;
        if (!isArr(arr)) {
            throw new TypeError();
        }
        if (typeof fun != "function") {
            throw new TypeError();
        }

        var res = new Array(len);
        for (var i = 0; i < len; i++) {
            if (i in arr) {
                res[i] = fun(arr[i]);
            }
        }
        return res;
    }

    function prependScriptBody(node, body) {
        var path = require('path');
        var preFile = path.resolve(__dirname,'../../../lib/profilerLib.js');

        var n_code = '\n    require("'+preFile+'");\n' + '\n';

        var ret = replaceInStatement(n_code+
            "\n try{"+RP+"1}\n catch (e) \n{ }\n finally \n{ JSProf.FLUSH(); }\n",
        body
        );
        return ret;
    }

    function wrapRead(node, logFuncName, ReUseLId) {
        var logFunction= logFunctionName ( loggerLib.consts.logRead );
        var lid;
        var ret;
        if (logFuncName !== undefined)
            logFunction = logFuncName;
        if (ReUseLId) {
            lid = getPreviousLId();
        }
        else
            lid = getLId();

        ret = replaceInExpr(
            logFunction+"("+RP+"1, " +RP+"2)",
            lid,
            node 
        );
        return ret;
    }

    function wrapReadWithUndefinedCheck(node) {
        var ret = replaceInExpr(
            logFunctionName( loggerLib.consts.logReadUndefined ) + "("+ RP+ "1, typeof " +  node.name + " === 'undefined' ?"+RP+"2: "+RP+"3) ",
            getLId(),
            createIdentifierAst("undefined"),
            node
        );
        return ret;
    }

    function wrapWrite(val, lhs, logFuncName) {
        var ret;
        ret = replaceInExpr(
            logFuncName+"("+RP+"1, "+RP+"2, "+RP+"3)",
            getLId(),
            lhs,
            val
        );
        return ret;
    }

    function wrapIW(node) {
        var ret = replaceInExpr(
            logFunctionName ( loggerLib.consts.logUndefined ) + "(typeof " +  RP+"1" + " === 'undefined' ?"+RP+"2: "+RP+"3)",
            node,
            createIdentifierAst("undefined"),
            node
        );
        return ret;
    }

    function wrapWriteWithUndefinedCheck(node, lhs, logFuncName) {
        var tret = wrapIW(createIdentifierAst(lhs.name));
        var ret = replaceInExpr(
            logFuncName+"("+RP+"1, "+RP+"2, "+RP+"3)",
            getLId(),
            tret,
            node
        );
        return ret;
    }

    function makeTempVar(node) {
        var tname = node.object.type + "-" + node.object.name;
        var sha1 = crypto.createHash("sha1");
        sha1.update(new Buffer(tname));
        return sha1.digest("hex").toString("utf8");
    }

    function wrapGetPutField(node, actionType) {
        if ( node.computed == true) {
            //console.log(JSON.stringify(node,'\t',4));
            if ( ( node.property.type === "Identifier" ) || ( node.property.type === 'Literal' ) ) {
                //return node; //TODO: FIX THIS
                var nproperty;
                if ( node.property.name == undefined) {
                    if (node.property.type == 'Literal') {
                        nproperty = createLiteralAst(node.property.value); 
                        //console.log("************");
                    }
                }
                else
                    nproperty = createLiteralAst(node.property.name);

                if (actionType == logFunctionName( loggerLib.consts.logGetFieldDot ))
                    actionType = logFunctionName( loggerLib.consts.logGetFieldBracket);
                else if (actionType === logFunctionName( loggerLib.consts.logPutFieldDot))
                    actionType = logFunctionName( loggerLib.consts.logPutFieldBracket );
                else if (actionType === logFunctionName( loggerLib.consts.logPutDotNull))
                    actionType = logFunctionName( loggerLib.consts.logPutBracketNull);


                ret = replaceInExpr(
                    //actionType+"("+RP+"1, "+RP+ "2, "+RP+"3, "+RP+"4)["+RP+"5]",
                    actionType+"("+RP+"1, "+RP+ "2, "+RP+"3)["+RP+"4]",
                    getLId(),
                    node.object,
                    nproperty,
                    //node,
                    node.property
                );
                return ret; 
            }
            else {
                if (actionType == logFunctionName( loggerLib.consts.logGetFieldDot))
                    actionType = logFunctionName( loggerLib.consts.logGetFieldBracket);
                else if (actionType === logFunctionName( loggerLib.consts.logPutFieldDot) )
                    actionType = logFunctionName( loggerLib.consts.logPutFieldBracket );
                else if (actionType === logFunctionName( loggerLib.consts.logPutDotNull))
                    actionType = logFunctionName( loggerLib.consts.logPutBracketNull);

                var hashedname = makeTempVar(node);
                hashedname = PREFIX1+".TMPS.t"+hashedname;
                var tret = replaceInExpr(
                    actionType+"("+RP+"1[ "+RP+ "2])",
                    node.object,
                    createIdentifierAst (hashedname));

                    ret = replaceInExpr(
                        //actionType+"("+RP+"1, "+RP+ "2, "+RP+"3 = "+RP+"4, "+RP+"5) ["+RP +"6]",
                        actionType+"("+RP+"1, "+RP+ "2, "+RP+"3 = "+RP+"4) ["+RP +"5]",
                        getLId(),
                        node.object,
                        createIdentifierAst (hashedname),
                        node.property, 
                        //tret.arguments[0],
                        createIdentifierAst (hashedname)
                    );
                    return ret; 
            }
        }
        else {
            ret =  replaceInExpr(
                actionType+"("+RP+"1, "+ RP+"2, "+RP+"3)."+RP+"4",
                getLId(),
                node.object,
                createLiteralAst(node.property.name),
                //node,
                node.property
            );
            return ret; 
        }
    }

    function instrumentLoad(node) {
        var ret;
        if (node.type === 'Identifier') {
            if (node.name === "undefined") {
                if (thatModule.options.LITERAL_INST==1) { 
                    ret = wrapLiteral(node, N_LOG_UNDEFINED_LIT);
                    return ret; 
                }
                else
                    return node;
            } else if (node.name === "NaN" || node.name === "Infinity") {
                if (thatModule.options.LITERAL_INST==1) { 
                    ret = wrapLiteral(node, N_LOG_NUMBER_LIT);
                    return ret; 
                }
                else
                    return node;
            } if(node.name === PREFIX1 ||
            node.name === "eval" || node.name === "arguments"){ //Last Condition is for Facebook
                return node; 
            } else if (scope.hasVar(node.name)) {
                ret = wrapRead(node);
                return ret; 
            } else {
                ret = wrapReadWithUndefinedCheck(node);
                return ret; 
            }    
        }
        else if ( node.type === 'MemberExpression' ) {
            ret = wrapGetPutField(node, logFunctionName( loggerLib.consts.logGetFieldDot));
            return ret;
        }
        else {
            return node;
        }
    }

    function instrumentLoadModStore(node) {
        return node;
        //Actually since all of the other operators are used on number, and 
        //we are not targetting number objects, so we skip wrting this function
        //at the moment.
        // It can be treated as a write, since it is written. The only 
        //difference is that the object is also being read. I just need
        //to apply instrumentLoad function with a different parameter.
        //if (node.left.type === 'Identifier') {
            //    var ret = instrumentLoad(node.left);
            //} else {
                //    return node;
                //}
                //return ret;
    }

    function instrumentGlobalVariableReference(node) {
        var ret;
        if (scope.hasVar(node.left.name)) { 
            ret = node.right; 
        } else { 
            ret = wrapRead(node.right,logFunctionName( loggerLib.consts.logGlobalVar));
        }   
        return ret;
    }

    function instrumentIdentifierSetNull(node) {
        var ret;
        if (scope.hasVar(node.left.name)) { // if a is already defined
            ret = wrapWrite(node.right, node.left, 
                logFunctionName( loggerLib.consts.logWriteNull));
        } else { 
            ret = wrapWriteWithUndefinedCheck(node.right, node.left, 
                logFunctionName( loggerLib.consts.logWriteUndefinedNull));   
        }   
        return ret;
    }

    function instrumentWriteToIdentifier(node) {
        var ret;
        if (scope.hasVar(node.left.name)) { // if a is already defined
            ret = wrapWrite(node.right, node.left, 
                logFunctionName( loggerLib.consts.logWrite));
        } else { // if a is not defined. Since JSRecord.Write calls a 
            //and if it is not defined results in an error in the 
            //generated code. Note that ' var a = ..' is OK. since 
            //it is inside a variable declaration

            //THIS WOULD MEAN A GLOBAL REFERENCE
            ret = wrapWriteWithUndefinedCheck(node.right, node.left, 
                logFunctionName( loggerLib.consts.logWriteUndefined));   
        }   
        return ret;
    }

    function instrumentAccumulationPoint(node, ReUseLId) {
        var ret;
        if (node.left.computed==true)
            ret = wrapRead(node.right, logFunctionName( loggerLib.consts.logRightSidePutBracket), ReUseLId);
        else
            ret = wrapRead(node.right, logFunctionName( loggerLib.consts.logRightSidePutDot), ReUseLId);
        return ret;
    }

    function instrumentStore(node) {
        var ret; 
        if (node.left.type === 'Identifier') { // a = 
            //if (thatModule.options.GLOBAL_VAR_REF===1) {
                //    ret = instrumentGlobalVariableReference(node);
                //    node.right = ret;
                // }   
                if (thatModule.options.WRITE_INST===1) {
                    if ((node.right.type==="Literal")&&(node.right.value===null)) {
                    }
                    else {
                        ret = instrumentWriteToIdentifier(node);
                        node.right = ret;
                    }
                }

                if (thatModule.options.RECORD_RIGHT_NULL===1) {
                    if ((node.right.type==="Literal")&&(node.right.value===null))  {
                        ret = instrumentIdentifierSetNull(node);   
                        node.right = ret;
                    }
                }
                return node;    
        } else {  //a.b = 

            var ReUseLId = false;
            var rightType=true;
            //TODO: remove the following, later add support for the case that
            // it is set to Null

            if ((node.right.type==="Literal")&&(node.right.value===null))  {
                rightType = false;
                if (thatModule.options.RECORD_RIGHT_NULL===1) {
                    ret = wrapGetPutField(node.left, logFunctionName(loggerLib.consts.logPutDotNull));
                    node.left = ret;
                }
            }
            else if (thatModule.options.WRITE_INST_EXP===1) {
                ReUseLId = true;
                ret = wrapGetPutField(node.left, logFunctionName(loggerLib.consts.logPutFieldDot));
                node.left = ret;
            }

            if ( (thatModule.options.ACCUMULATION_POINT==1) && (rightType===true)) {
                // get the iid of the left side and use that for the right
                // TODO in script to process data: connect the container on the
                // left side and the object on the right side by wrapping the 
                // right one.
                ret = instrumentAccumulationPoint(node, ReUseLId);
                node.right = ret;
            }
            return node; 
        }    
    }


    function getPropertyAsAst(ast) {
        return ast.computed?ast.property:createLiteralAst(ast.property.name);
    }

    function replaceInStatement(code) {
        //Here is the part for making the part that is needed to be added to the AST.
        var asts = arguments;
        //Here asts in a closure, that's why the visitorReplaceInExpr can access
        //its value later when it is being called
        var visitorReplaceInExpr = {
            'Identifier': function(node) {
                if (node.name.indexOf(RP) === 0) {
                    var i = parseInt(node.name.substring(RP.length));
                    return asts[i];
                } else {
                    return node;
                }
            },

            'BlockStatement' : function(node) {
                if (node.body[0] != undefined) {
                    if (node.body[0].type === 'ExpressionStatement' && isArr(node.body[0].expression)) {
                        node.body = node.body[0].expression;
                    }
                }
                return node;
            }
        }

        var ast = esprima.parse(code);
        var newAst = transformAst(ast, visitorReplaceInExpr, undefined, undefined);
        return newAst.body;
    }

    function replaceInExpr(code) {
        var ret =  replaceInStatement.apply(this,arguments);
        return ret[0].expression;
    }

    function wrapMethodCall(node, base, offset , property, isCtor) {
        if (node.computed === true ) { //TO handle cases such as a[0]() which happened in google; to handle the case where the parameter is an expression:
            var hashedname = makeTempVar(node);
            hashedname = PREFIX1+".TMPS.t"+hashedname;
            var type=1;
            var ret = replaceInExpr( 
                //logFunctionName( loggerLib.consts.logMethodCall) + "("+RP+"1, "+RP+"2, "+RP+"3, "+RP+"4)["+RP+"5]", 
                logFunctionName( loggerLib.consts.logMethodCall) + "("+RP+"1, "+RP+"2, "+RP+"3 = "+RP+"4, "+RP+"5)["+RP+"6]", 
                getLId(),
                base,
                createIdentifierAst (hashedname),
                offset,
                createLiteralAst(type),
                createIdentifierAst (hashedname)
                //property
            );
            return ret; 
        }
        //TODO: handle the case where node.computed === false, e.g., a[i++]()
        else {
            var ret = replaceInExpr( 
                logFunctionName( loggerLib.consts.logMethodCall) + "("+RP+"1,  "+RP+"2, "+RP+"3)."+RP+"4", 
                getLId(),
                base,
                createLiteralAst(node.property.name),
                node.property
            ); 
            return ret; 
        }
    }

    function wrapFunCall(ast, isCtor) {
        var ret = replaceInExpr(
            logFunctionName( loggerLib.consts.logFuncCall) +"("+RP+"1, "+RP+"2, "+(isCtor?"true":"false")+")",
            getLId(),
            ast
        );
        return ret;
    }


    function stopInstrumentingCallExpression(node) {
        /*if ( (node.callee.type==='MemberExpression') && 
        (node.callee.object.name === 'object') &&
        (node.callee.property.name === 'create')
        )
        { 
        return true;
        //ret = wrapNewExpression(node, 'objcreate'); //TODO: wrap object.create()
        }*/
        if ( (node.callee.type==='MemberExpression') &&
        (node.callee.object.name === 'goog') &&  
        ( (node.callee.property.name === 'base')|| 
        (node.callee.property.name === 'inherits') ||
        (node.callee.property.name === 'require') 
        )
        )
        {
            return true;
        }

        if ( (node.callee.type==='MemberExpression') && ( (node.callee.property.name === 'bind')  )   )
        {
            return true;
        }

        if (node.callee.name === "setTimeout")   //for Facebook
            return true;

        return false;
    }


    //TODO, do the same for access to native properties! 
    // arguments, length, keys

    //TODO: Also do this during runtime, so that the info for these are not
    //sent to the proxy. This reduces the communication overhead.

    //TODO: add this point to the paper that by dynamic analysis, we resolve
    //those issue that mentioned in that ECOOP paper about object.create!
    //Actually in the profilerLib is more important. Since the network overhead
    //is much higher than size overhead.

    var NoInstrumentPropertiesName=['replace', 'call', 'apply', 'substr', 'push',
        'get', 'join', 'split', 'getElementById', 'valueOf', 
        'indexOf', 'unshift',
        'exec',   //RegExp
        'getTime', //Date
        'createTextNode', 'createElement', 'execCommand', //DOM
        'queryCommandSupported', 'getElementsByTagName',              //DOM
        'charAt',
        'slice',  //Array
        'dispatchEvent', 'toLowerCase', 'focus',
        'addEventListener', 'attachEvent', 'preventDefault', 'send', 'error', 'match','open',
        'setRequestHeader', 'setTimeout', 'clearTimeout',
        'toString', 'toLocaleString', 'seal', 'getSelection', 'isCollapsed', 
        'prototype', 'propertyIsEnumerable', 
        'preventExtensions', 'name', 'isSealed', 
        'isPrototypeOf', 'isFrozen', 'isExtensible', 
        'hasOwnProperty', 'is', 'getPrototypeOf', 
        'getOwnPropertyNames', 'getOwnPropertyDescriptor',
        'freeze', 'defineProperty', 'defineProperties', 
        'create', 'caller', 'constructor', 'call', 'bind',
    'apply'];

    // For some functions, event though it is a native function, the program 
    // creates a new Definition. For example, I have seend for the 
    // isCollapsed, dispatchEvent in Gmail.
    // If when referencing to this function, the object id is created before, 
    // this means that this function is defined by the program, otherwise, it means that
    // It is using the definition by the program. although this means that we need to 
    //perform the instrumentation.
    //This is even true for push and get.

    //TODO: make this list complete
    var NoInstrumentNoChange=['toLocaleString', 'exec', 'getElementsByTagName',
        'insertBefore', 'charAt', 'substring', 'clearTimeout',
        'concat', 'toLowerCase', 'split', 'unshift', 'toUpperCase',
        'isDisposed', 'toString', '_DumpException', 'dispatchEvent'
    ];
    // 'getElementById', 'createElement',
    // 'appendChild',
    // 'toString', 'removeChild', 'pop'


    function checkToInstrument(node, level) {

        if (NoInstrumentNoChange.indexOf( node.property.name ) >=0 )
            return 1;

        if ( ( (node.object.name==="console") && (node.property.name==="log") ) ||
        ( (node.object.name==="Math") && ( (node.property.name==="random")|| (node.property.name==="floor") || (node.property.name==="pow"))) ||
        ( (node.object.name==="window") && (node.property.name==="postMessage") )
        ){
            return 1;
        }
        //console.log(node.property.name);
        return 0;
    }

    function instrumentCall(ast, isCtor) {
        var ret;
        if (ast.type==='MemberExpression') {
            if (checkToInstrument(ast,0) == 1) //TODO
                return ast;
            else {
                ret = wrapMethodCall(ast, ast.object, getPropertyAsAst(ast), 
                ast.property, isCtor);
                return ret;
            }

        } else if (ast.type ==='Identifier' && ast.name === "eval") {
            return ast;
        } else {
            ret = wrapFunCall(ast, isCtor);
            return ret;
        }
    }

    function wrapRHSOfModStore(node, left, right, op) {

        var ret = replaceInExpr( RP+"1 "+op+" "+RP+"2",
        left, right);
        return ret;
    }

    //TODO: Identify the name of function that is wrapped, although in
    //case of renaming this does not hold.
    function wrapCallExp(ast) {
        var ret =  replaceInExpr(
            logFunctionName( loggerLib.consts.logCallExp) +"("+RP+"1, "+RP+"2)",
            getLId(),
            ast
        );
        return ret;
    }

    function wrapNewExpression(ast, objTypeName, newType) {
        var ret =  replaceInExpr(
            logFunctionName( newType )+"("+RP+"1, "+RP+"2, "+RP+"3)",
            getLId(),
            ast,
            createLiteralAst(objTypeName)
        );
        return ret;
    }

    function wrapLiteral(node, funId) {
        var ret =  replaceInExpr(
            logFunctionName( loggerLib.consts.logLiteral)+"("+RP+"1, "+RP+"2, "+RP+"3)",
            getLId(),
            node,
            createLiteralAst(funId)
        );

        return ret;
    }

    function instrumentPreIncDec(node) {
        var right = createLiteralAst(1);
        var ret = wrapRHSOfModStore(node, node.argument, right, node.operator.substring(0,1)+"=");
        var ret2 =  replaceInExpr( RP+"1 =  " + logFunctionName( loggerLib.consts.logWrite)  +"( "+RP+"2 )",
        node.argument, ret);

        return ret2;
    }

    function createContextReference(node, val, func) {

        var ret =replaceInStatement(
            logFunctionName( loggerLib.consts.logCreateContextReference )+"("+RP+"1, "+RP+"2, "+RP+"3)",
            getLId(),
            val,
            func
        );

        return ret;
    }



    function createCallInitAsStatement(node, name, val, isArgumentSync) {
        //name is added in the above to differentiate betweeen functions allocated within a scope

        var ret =replaceInStatement(
            logFunctionName( loggerLib.consts.logFuncDeclaration)+"("+RP+"1, "+RP+"2 )",
            getLId(),
            //name,
            val
        );

        return ret;
    }

    //TODO: closure reference should be done on function arguments as well.
    function syncCreateRef (node, scope, isScript) {
        var ret = [];
        //TODO: complete implenting context refences
        if (scope) {
            for (var name in scope.vars) {
                if (HOP(scope.vars, name)) {
                    if (scope.vars[name] ==="var") {
                        console.log("name...."+name);
                        estraverse.traverse(node, {
                            enter: function(thisnode){
                                if ((thisnode.type == 'FunctionDeclaration'))
                                {
                                    console.log(thisnode.type);
                                    console.log(thisnode.id.name);
                                    console.log(scope.vars);
                                    if (scope.vars[thisnode.id.name] !== undefined) {
                                        if (scope.vars[thisnode.id.name] === "defun") {
                                            var testUsedinFunc=false;

                                            console.log('...........');
                                            estraverse.traverse(thisnode, {
                                                enter: function(thenode) {
                                                    if ((thenode.type == 'Identifier')&& (thenode.name===name))
                                                        testUsedinFunc=true;

                                                }
                                            });

                                            if (testUsedinFunc)
                                                ret = ret.concat(createContextReference(node,
                                                    createIdentifierAst(name),
                                                    createLiteralAst(thisnode.id.name)
                                                )); 
                                        }
                                    }
                                }
                                else if ((thisnode.type == 'FunctionExpression')) {
                                }
                            }
                        });
                    }

                    /*if (scope.vars[name] ==="var") {
                        //check to see if the function closes over any variable
                        //get the local variables of the parent scope
                        //and applycontex reference to them.

                        var parentScope = scope.getParentScope();
                        if (parentScope!==null) {
                        for (var varname in parentScope.vars) {
                        if ( parentScope.vars[varname] === "var" ) {

                        var testUsedinFunc=false;
                        estraverse.traverse(node, {
                        enter: function(thisnode){
                        if ((thisnode.type == 'Identifier')&& (thisnode.name===varname))
                        {
                        testUsedinFunc=true;
                        /* console.log("***************");
                        ret = ret.concat(createContextReference(node,
                        createIdentifierAst(name))); //*
                        }
                        }
                        });

                        if (testUsedinFunc) {
                        ret = ret.concat(createContextReference(node,
                        //createLiteralAst(name)));
                        createIdentifierAst(name)));
                        }

                        }   
                        }
                        }
                } */ 



                }
            }

        }
        return ret; 
    }  

    function syncDefuns(node, scope, isScript) {
        var ret = [];
        /* if(!isScript) {
            ret = ret.concat(createCallInitAsStatement(node,
            createLiteralAst("arguments"),
            createIdentifierAst("arguments"),
            true));
            }*/

            if (scope){
                for (var name in scope.vars) {
                    if (HOP(scope.vars, name)) {
                        if (scope.vars[name] ==="defun") {
                            var ident = createIdentifierAst(name);
                            ret = ret.concat(createCallInitAsStatement(node,
                                createLiteralAst(name),
                                //wrapLiteral(ident, ident, N_LOG_FUNCTION_LIT), //No Need to wrap this one
                                ident,
                            false));

                        }


                        /*       if (scope.vars[name] ==="arg") {
                            ret = ret.concat(createCallInitAsStatement(node,
                            createLiteralAst(name),
                            createIdentifierAst(name),
                            true));
                            }    
                            if (scope.vars[name] ==="var") {
                            ret = ret.concat(createCallInitAsStatement(node,
                            createLiteralAst(name),
                            createIdentifierAst(name),
                            false));
                            } */
                    }    
                }    
            }    
            return ret; 
    }    

    var scope;

    function setScope(node) {
        scope = node.scope;
    }

    var visitorRRPre = {
        'Program': setScope,
        'FunctionDeclaration': setScope,
        'FunctionExpression': setScope
    }

    var visitorRRPost = {
        'Literal': function(node, context) {

            if (thatModule.options.LITERAL_INST == 0)
                return node;
            else
            {
                if (context === CONTEXT.RHS){
                    var litType;
                    switch(typeof node.value) {
                        case 'number':
                            litType = N_LOG_NUMBER_LIT;
                            break;
                        case 'string':
                            litType = N_LOG_STRING_LIT;
                            break;
                        case 'object': // for null
                            if (node.value === null)
                                litType = N_LOG_NULL_LIT;
                            else 
                                litType = N_LOG_REGEXP_LIT;
                            break;
                        case 'boolean':
                            litType = N_LOG_BOOLEAN_LIT;
                            break;
                    }  
                    var ret = wrapLiteral(node, litType);
                    return ret;
                } else {
                    return node;
                }
            }
        },  

        'Program': function(node) {

            var ret;
            if (thatModule.options.PROGRAM_INST==1) {
                ret = instrumentScriptEntryExit(node, node.body);
                node.body = ret;
            }
            if (thatModule.options.INFILE_INST == 1) {
                //To run in Proxy mode, the following two lines should be 
                //commented. To run in local mode, we need them to add the
                //content of profilerLib.js to the beginnign of the 
                //instrumented file
                ret = prependScriptBody(node, node.body);
                node.body = ret;
            }
            scope = scope.parent;
            return node;
        },

        'VariableDeclaration': function (node) {  
            // TODO: any reference is created here? global, local? 
            // What about accesses. Here a write happend, but we are not 
            // monitoring writes. local references are not monitored. Only
            // if it is a global reference, then  it adds a reference. 
            // knowing whether it is a global reference or not needs looking
            //into scope variable. If the parent of a scope is null then it
            // is considered a global reference. Please note that in doing 
            // so, we need to add references that are created using 
            // an assignment expression without a variable declaration.
            var declarations = MAP(node.declarations, function(def){
                if (def.init !== null) {
                    var init = def.init; //TODO: call wrapWrite here. 
                    def.init = init;
                }
                return def;
            });
            node.declarations = declarations;
            return node;
        },

        'NewExpression': function(node) {
            if (thatModule.options.NEWEXPRESSION_INST == 0)
                return node;
            else {    
                var objKind;
                if ( node.callee.type == 'Identifier' )
                    objKind = node.callee.name
                else if (node.callee.type == 'MemberExpression')    
                    objKind = N_LOG_OBJECT_NEW_INSTANCE
                else 
                    objKind = node.callee.type;

                node.callee = instrumentCall(node.callee, true);
                var ret1 = wrapNewExpression(node, objKind, loggerLib.consts.logNewObject );
                return ret1;
            }
        },


        "CallExpression": function(node) {
            var ret;
            if ((thatModule.options.CALLEXP_INST==0)||(stopInstrumentingCallExpression(node))) {
                ret = node;
            }    
            else {
                var isEval = node.callee.type === 'Identifier' && 
                node.callee.name === "eval";

                var callee = instrumentCall(node.callee, false);
                node.callee = callee;
                if (isEval) {
                    return node;
                    node.arguments = MAP(node.arguments, wrapEvalArg); // TODO
                }
                ret = node;
            }
            return ret;
        },

        'AssignmentExpression': function(node) {
            if (thatModule.options.ASSIGNMENT_INST==0)
                return node;
            else {
                var ret;
                if ( node.operator === "=" ) {
                    ret = instrumentStore(node);
                }
                else
                    ret = instrumentLoadModStore(node);
                return ret;
            }
        },
        //TODO: monitor function arguments as accesses
        'FunctionExpression': function(node) {
            if (thatModule.options.FUNCTINEXP_INST==0) {
                scope = scope.parent;
                return node;
            }
            else {
                node.body.body = instrumentFunctionEntryExit(node, node.body.body);
                var ret = wrapNewExpression(node, N_LOG_FUNCTION_LIT, loggerLib.consts.logNewFunction );
                scope = scope.parent;
                return ret;
            }
        },
        "FunctionDeclaration": function(node) {
            if (thatModule.options.FUNCDECL_INST==0) {
                scope = scope.parent; //TODO: what's the use of this!!!!!!
                return node;
            }
            else {
                node.body.body = instrumentFunctionEntryExit(node, node.body.body);
                scope = scope.parent;
                return node; 
            }
        },
        "ObjectExpression": function(node) {
            if (thatModule.options.OBJEXP_INST==0)
                return node;
            else {    
                var ret1 = wrapNewExpression(node, N_LOG_OBJECT_LIT, loggerLib.consts.logNewObject );
                return ret1;
            }
        },
        "UnaryExpression":function(node) {
            return node;
        },
        "ArrayExpression": function(node) {
            if (thatModule.options.ARRAYEXP_INST==0)
                return node;
            else {    
                var ret1 = wrapNewExpression(node, N_LOG_ARRAY_LIT, loggerLib.consts.logNewObject );
                return ret1;
            }
        },

        'Identifier': function(node, context) {
            if (thatModule.options.IDENTIF_INST==0) 
                return node;
            else {    
                if (context === CONTEXT.RHS){
                    var ret = instrumentLoad(node);
                    return ret; 
                } 
                else {
                    return node;
                }    
            }
        },   

        'MemberExpression': function(node, context) {
            if (thatModule.options.MEMBEREXP_INST==0)
                return node;
            else {    
                if (context === CONTEXT.RHS) {
                    var ret = instrumentLoad(node);
                    return ret;
                } else {
                    return node;
                }
            }
        },

        'ForInStatement': function(node) {
            //TODO
            //var ret = instrumentLoad(node.right);
            //node.right = ret;
            return node;
        }
    }

    function instrumentScriptEntryExit(node, body) {
        var ret = syncDefuns(node, scope, true).concat(body);
        return ret;
    }

    function   instrumentFunctionEntryExit (node, ast) {
        var t2 = syncDefuns(node, scope, false);
        var body = t2.concat(ast);

        //TODO: update this later:
        //var t3 = syncCreateRef(node, scope, false);
        //body = t3.concat(ast);
        return body;
    }

    function transformAst(node, visitorPost, visitorPre, context) {
        var key, child, type, ret, newContext;
        type = node.type;  


        if (visitorPre && HOP(visitorPre,type))
            visitorPre[type](node, context);

        for (var key in node) {
            if (node.hasOwnProperty(key)) { 
                if (type === 'Property' && ( node.kind === 'get' || node.kind=== 'set' ) )
                    continue;
                child = node[key];
                if (typeof child === 'object' && child !== null ) { 
                    //if ( type === 'MemberExpression' && node.computed )
                        if ( (type === 'AssignmentExpression' && key === 'left') 
                            || (type === 'UpdateExpression' && key === 'argument')
                        || ( (type === 'CallExpression' || type === 'NewExpression') && 
                        key === 'callee' && 
                        (node.callee.type === 'MemberExpression' || node.callee.type === 'Identifier'  || 
                            (node.callee.type === 'Identifier' && node.callee.name === 'eval')))
                            || ((type === 'FunctionExpression' || type === 'FunctionDeclaration') && key === 'id')
                            || ((type === 'FunctionDeclaration') && key === 'id')
                            || (type === 'ForInStatement' && key === 'left') 
                            || (type === 'MemberExpression' && !node.computed && key === 'property')
                            || (type === 'MemberExpression' && !node.computed && key === 'object' && key.type !== 'MemberExpression') //TODO: why did you add these two lines at first!!! It is related to wrapGetPutField
                            || (type === 'MemberExpression' && node.computed && key === 'object' )
                            || (type === 'MemberExpression' && node.computed && key === 'property') //Think!!
                            || (type === 'VariableDeclarator' && key === 'id') 
                            || (type === 'UnaryExpression' && key === 'argument' && node.operator === 'delete') 
                            || (type == 'ThrowStatement' && key === 'argument' )
                            || (type === 'NewExpression' && key === 'callee'  )
                            || (type === 'CatchClause' && key ==='param')
                            || (type === 'CatchClause' && key ==='body')
                            || (type === 'LabeledStatement' && key ==='label')
                            || (type === 'ContinueStatement' && key ==='label')
                            || (type === 'BreakStatement' && key ==='label')
                        ) {

                            newContext = CONTEXT.IGNORE;
                        }
                        else if ( ((type === 'FunctionExpression' || type === 'FunctionDeclaration') && key === 'params') ){
                            newContext = CONTEXT.PARAMS;
                        }
                        /*           else if (type === 'UpdateExpression' && key === 'argument') {
                            CONTEXT.INC;
                            }*/
                            else if (context === CONTEXT.PARAMS) {
                                newContext = CONTEXT.IGNORE;
                            }
                            else if (type === 'ObjectExpression' && key === 'properties') {
                                newContext = CONTEXT.OEXP;
                            }
                            else if (context===CONTEXT.OEXP) {
                                newContext = CONTEXT.OEXP2;
                            }
                            else if (context===CONTEXT.OEXP2 && key === 'key') {
                                newContext = CONTEXT.IGNORE;
                            }
                            else if (context===CONTEXT.OEXP2 && key === 'value') {
                                newContext = CONTEXT.OEXP3;
                            }
                            else if (context===CONTEXT.OEXP3)
                                newContext = CONTEXT.IGNORE;

                            else if (context === CONTEXT.INC) {
                                newContext = CONTEXT.IGNORE;
                            }
                            else {
                                newContext = CONTEXT.RHS;
                            }
                            node[key] = transformAst(child, visitorPost, visitorPre, newContext);
                }
            }
        }
        if (visitorPost && HOP(visitorPost, type) ) {
            ret = visitorPost[type](node, context);
        }
        else
            ret = node;
        return ret;
    }

    function addScopes(ast) {
        function Scope(parent) {
            this.vars = {};
            this.hasEval = false;
            this.hasArguments = false;
            this.parent = parent;
        }
        Scope.prototype.addVar = function(name, type, loc) {
            this.vars[name] = type;
        };


        Scope.prototype.hasVar = function(name) {
            var s = this;
            while (s !== null) {
                if (HOP(s.vars,name))
                    return s.vars[name];
                s = s.parent;
            }
            return null;
        };

        Scope.prototype.addEval = function() {
            var s = this;
            while (s !== null) {
                s.hasEval = true;
                s = s.parent;
            }
        };

        Scope.prototype.addArguments = function() {
            var s = this;
            while (s !== null) {
                s.hasArguments = true;
                s = s.parent;
            }
        };

        Scope.prototype.usesEval = function() {
            return this.hasEval;
        };

        Scope.prototype.usesArguments = function() {
            return this.hasArguments;
        };


        var currentScope = null;

        function handleFun(node) {
            var oldScope = currentScope;
            currentScope = new Scope(currentScope);
            node.scope = currentScope;
            if (node.type === 'FunctionDeclaration') {
                oldScope.addVar(node.id.name, "defun", node.loc);
                MAP(node.params, function(param) {
                    currentScope.addVar(param.name, "arg");
                })
            } else if (node.type === 'FunctionExpression') {
                if (node.id !== null) {
                    currentScope.addVar(node.id.name, "lambda");
                }
                MAP(node.params, function(param) {
                    currentScope.addVar(param.name, "arg");
                })
            }
        }

        function handleVar(node) {
            currentScope.addVar(node.id.name, "var");
        }

        function handleCatch(node) {
            currentScope.addVar(node.param.name, "catch");
        }

        function popScope(node) {
            currentScope = currentScope.parent;
            return node;
        }

        var visitorPre = {
            'Program': handleFun,
            'FunctionDeclaration': handleFun,
            'FunctionExpression': handleFun,
            'VariableDeclarator': handleVar,
            'CatchClause': handleCatch
        }

        var visitorPost = {
            'Program': popScope,
            'FunctionDeclaration': popScope,
            'FunctionExpression': popScope
        }

        transformAst(ast, visitorPost, visitorPre);
    }

    this.instrument = function(code) {
        if (this.options.PARSING_MODE === "UNMODIFIED")
            return code;

        var parseoptions = { comment: true, range: true, tokens: true };
        var codegenerateoptions = { comment: true, format: { indent: { adjustMultilineComment: true} }, parse: esprima.parse};

        var ast = esprima.parse(code, parseoptions);
        ast = escodegen.attachComments(ast, ast.comments, ast.tokens);

        if (this.options.PARSING_MODE === "MINIFIED" ) {
            return escodegen.generate(ast, codegenerateoptions);
        }

        if ( (this.options.PARSING_MODE === "PARSE") ) {
            addScopes(ast);
            ast = transformAst(ast, visitorRRPost, visitorRRPre,  CONTEXT.RHS);
        }

        var newCode = escodegen.generate(ast, codegenerateoptions);
        return newCode;
    }
}
